# Sequenzia AI - Complete Project Recreation Guide

This document provides comprehensive instructions for an AI agent to recreate the Sequenzia AI chat application from scratch.

---

## Table of Contents

1. [Project Overview](#project-overview)
2. [Tech Stack](#tech-stack)
3. [Step-by-Step Recreation](#step-by-step-recreation)
4. [Directory Structure](#directory-structure)
5. [Configuration Files](#configuration-files)
6. [Core Implementation](#core-implementation)
7. [AI Integration](#ai-integration)
8. [Component Architecture](#component-architecture)
9. [State Management](#state-management)
10. [Styling System](#styling-system)
11. [Animation System](#animation-system)
12. [Type Definitions](#type-definitions)

---

## Project Overview

Sequenzia AI is a modern chat interface built on Next.js 16 that demonstrates advanced AI integration patterns using Vercel's AI SDK v6. The application features:

- Real-time streaming chat with multiple AI models
- Interactive content blocks (forms, charts, code, cards) generated by AI tools
- Theme switching (light/dark/system)
- Model selection with multi-provider support via Vercel AI Gateway
- Polished animations using Framer Motion
- Accessible UI components via shadcn/ui and Radix UI

---

## Tech Stack

### Core Framework
- **Next.js 16.1** - React framework with App Router
- **React 19.2** - UI library with Server Components support
- **TypeScript 5** - Type safety

### AI/LLM Integration
- **Vercel AI SDK v6** (`ai@6.0.5`) - Core AI functionality
- **@ai-sdk/react** - React hooks (`useChat`)
- **@ai-sdk/gateway** - Multi-provider model routing
- **Vercel AI Elements** - Pre-built chat UI components (Conversation, Message, PromptInput, Tool, Reasoning, CodeBlock, Loader, ModelSelector)
- **Zod v4** - Schema validation for tool inputs

### UI Components
- **shadcn/ui** (New York style) - Component primitives
- **Radix UI** - Accessible headless components
- **Lucide React** - Icon library
- **Recharts** - Chart visualization
- **Shiki** - Syntax highlighting

### Styling & Animation
- **Tailwind CSS v4** - Utility-first CSS
- **Framer Motion / Motion** - Animation library
- **class-variance-authority** - Component variants

### State Management
- **React Context** - Local state sharing
- **TanStack Query** - Server state caching
- **Vercel AI SDK** - Chat state management

---

## Step-by-Step Recreation

### Phase 1: Project Setup

```bash
# 1. Create Next.js project
npx create-next-app@latest sequenzia-ai --typescript --tailwind --eslint --app --src-dir

# 2. Install core dependencies
npm install ai@^6 @ai-sdk/react @ai-sdk/gateway @ai-sdk/openai @ai-sdk/anthropic zod@^4

# 3. Install UI dependencies
npm install @radix-ui/react-avatar @radix-ui/react-collapsible @radix-ui/react-dialog \
  @radix-ui/react-dropdown-menu @radix-ui/react-hover-card @radix-ui/react-label \
  @radix-ui/react-progress @radix-ui/react-scroll-area @radix-ui/react-select \
  @radix-ui/react-separator @radix-ui/react-slot @radix-ui/react-tooltip

# 4. Install utility dependencies
npm install class-variance-authority clsx tailwind-merge cmdk lucide-react nanoid

# 5. Install animation dependencies
npm install framer-motion motion

# 6. Install additional dependencies
npm install @tanstack/react-query react-hook-form @hookform/resolvers recharts shiki \
  use-stick-to-bottom sonner server-only

# 7. Install dev dependencies
npm install -D @ai-sdk/devtools tw-animate-css
```

### Phase 2: Configure shadcn/ui

Create `components.json`:
```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {
    "@ai-elements": "https://registry.ai-sdk.dev/{name}.json"
  }
}
```

Install shadcn/ui components:
```bash
npx shadcn@latest add button card input textarea label badge alert skeleton \
  dropdown-menu dialog hover-card collapsible tooltip select command scroll-area \
  separator avatar form carousel progress
```

Install AI Elements:
```bash
npx shadcn@latest add @ai-elements/conversation @ai-elements/message \
  @ai-elements/prompt-input @ai-elements/code-block @ai-elements/tool \
  @ai-elements/reasoning @ai-elements/loader @ai-elements/model-selector
```

### Phase 3: Environment Setup

Create `.env.local`:
```env
AI_GATEWAY_API_KEY=your_vercel_ai_gateway_key
AI_DEBUG=false  # Set to true for DevTools
```

---

## Directory Structure

```
sequenzia-ai/
├── src/
│   ├── app/
│   │   ├── api/
│   │   │   └── chat/
│   │   │       └── route.ts          # Streaming chat endpoint
│   │   ├── layout.tsx                # Root layout with providers
│   │   ├── page.tsx                  # Main chat page
│   │   ├── globals.css               # Tailwind + CSS variables
│   │   └── favicon.ico
│   ├── components/
│   │   ├── ai-elements/              # AI SDK component wrappers
│   │   │   ├── conversation.tsx
│   │   │   ├── message.tsx
│   │   │   ├── prompt-input.tsx
│   │   │   ├── code-block.tsx
│   │   │   ├── tool.tsx
│   │   │   ├── reasoning.tsx
│   │   │   ├── loader.tsx
│   │   │   └── model-selector.tsx
│   │   ├── blocks/                   # Content block renderers
│   │   │   ├── ContentBlock.tsx      # Router component
│   │   │   ├── FormContent.tsx
│   │   │   ├── ChartContent.tsx
│   │   │   ├── CodeContent.tsx
│   │   │   └── CardContent.tsx
│   │   ├── chat/                     # Chat components
│   │   │   ├── ChatProvider.tsx      # Chat context + useChat
│   │   │   ├── ChatContainer.tsx     # Message display
│   │   │   ├── ChatMessage.tsx       # Message renderer
│   │   │   └── InputComposer.tsx     # Input + model selector
│   │   ├── providers/
│   │   │   ├── ThemeProvider.tsx     # Theme context
│   │   │   └── QueryProvider.tsx     # TanStack Query
│   │   ├── ui/                       # shadcn/ui components
│   │   └── Header.tsx
│   ├── lib/
│   │   ├── ai/
│   │   │   ├── models.ts             # Client-safe model definitions
│   │   │   ├── models.server.ts      # Server-only model factory
│   │   │   ├── tools.ts              # Tool definitions
│   │   │   └── prompts.ts            # System prompt
│   │   ├── motion/
│   │   │   ├── variants.ts           # Animation variants
│   │   │   ├── hooks.ts              # Motion hooks
│   │   │   └── index.ts
│   │   └── utils.ts                  # Utility functions
│   └── types/
│       ├── message.ts                # Content block types
│       ├── conversation.ts
│       ├── theme.ts
│       └── index.ts
├── components.json
├── next.config.ts
├── tsconfig.json
├── package.json
└── .env.local
```

---

## Configuration Files

### next.config.ts
```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  // Add configuration as needed
};

export default nextConfig;
```

### tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

---

## Core Implementation

### 1. Root Layout (`src/app/layout.tsx`)

```typescript
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ThemeProvider } from "@/components/providers/ThemeProvider";
import { QueryProvider } from "@/components/providers/QueryProvider";
import { Toaster } from "sonner";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Sequenzia AI",
  description: "AI assistant with expanding interactive content",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider defaultTheme="system">
          <QueryProvider>
            {children}
            <Toaster position="bottom-right" />
          </QueryProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}
```

### 2. Main Page (`src/app/page.tsx`)

```typescript
'use client';

import { ChatProvider } from '@/components/chat/ChatProvider';
import { ChatContainer } from '@/components/chat/ChatContainer';
import { InputComposer } from '@/components/chat/InputComposer';
import { Header } from '@/components/Header';

export default function Home() {
  return (
    <ChatProvider>
      <div className="flex flex-col h-screen bg-background">
        <Header />
        <ChatContainer className="flex-1" />
        <InputComposer />
      </div>
    </ChatProvider>
  );
}
```

---

## AI Integration

### 1. Model Definitions (`src/lib/ai/models.ts`)

```typescript
export interface Model {
  id: string;
  name: string;
  provider: string;
  providerSlug: string;
  description?: string;
}

export const MODELS: Model[] = [
  {
    id: "openai/gpt-5-nano",
    name: "GPT-5 Nano",
    provider: "OpenAI",
    providerSlug: "openai",
    description: "Fast and efficient",
  },
  {
    id: "openai/gpt-4o-mini",
    name: "GPT-4o Mini",
    provider: "OpenAI",
    providerSlug: "openai",
    description: "Fast and efficient",
  },
  {
    id: "google/gemini-2.0-flash",
    name: "Gemini 2.0 Flash",
    provider: "Google",
    providerSlug: "google",
    description: "Fast multimodal model",
  },
];

export const DEFAULT_MODEL_ID = "openai/gpt-5-nano";

export function getModelById(id: string): Model | undefined {
  return MODELS.find((model) => model.id === id);
}

export function isValidModelId(id: string): boolean {
  return MODELS.some((model) => model.id === id);
}
```

### 2. Server Model Factory (`src/lib/ai/models.server.ts`)

```typescript
import "server-only";

import { gateway, wrapLanguageModel, type LanguageModel } from "ai";
import { devToolsMiddleware } from "@ai-sdk/devtools";
import { DEFAULT_MODEL_ID, isValidModelId } from "./models";

const isDebugEnabled = process.env.AI_DEBUG === "true";

export function createModel(modelId?: string): LanguageModel {
  const selectedModelId = isValidModelId(modelId ?? "") ? modelId! : DEFAULT_MODEL_ID;
  const baseModel = gateway(selectedModelId);

  return isDebugEnabled
    ? wrapLanguageModel({ model: baseModel, middleware: devToolsMiddleware() })
    : baseModel;
}
```

### 3. Tool Definitions (`src/lib/ai/tools.ts`)

```typescript
import { tool } from 'ai';
import { z } from 'zod';
import {
  FormFieldSchema,
  ChartContentDataSchema,
  CodeContentDataSchema,
  CardContentDataSchema,
} from '@/types/message';

export const generateForm = tool({
  description:
    'Generate an interactive form for collecting user input. Use this for surveys, registrations, feedback forms, or any structured data collection.',
  inputSchema: z.object({
    type: z.literal('form'),
    title: z.string().describe('The form title'),
    description: z.string().optional().describe('Optional description'),
    fields: z.array(FormFieldSchema).describe('Array of form fields'),
    submitLabel: z.string().optional().describe('Custom submit button label'),
  }),
  strict: true,
  execute: async (params) => params,
});

export const generateChart = tool({
  description:
    'Generate a data visualization chart. Include "data" array with {label, value} objects.',
  inputSchema: ChartContentDataSchema,
  strict: true,
  execute: async (params) => params,
});

export const generateCode = tool({
  description:
    'Generate a code block with syntax highlighting.',
  inputSchema: CodeContentDataSchema,
  strict: true,
  execute: async (params) => params,
});

export const generateCard = tool({
  description:
    'Generate a rich content card for displaying structured information.',
  inputSchema: CardContentDataSchema,
  strict: true,
  execute: async (params) => params,
});

export const chatTools = {
  generateForm,
  generateChart,
  generateCode,
  generateCard,
};
```

### 4. System Prompt (`src/lib/ai/prompts.ts`)

```typescript
export function getSystemPrompt(): string {
  return `You are Sequenzia, a helpful AI assistant with the ability to create interactive content.

When appropriate, you can generate:
- **Forms**: For collecting user input (surveys, registrations, feedback)
- **Charts**: For visualizing data (line, bar, pie, area charts)
- **Code**: For displaying code snippets with syntax highlighting
- **Cards**: For presenting structured information with optional media

Use these tools when they would enhance the conversation. For simple text responses, just reply normally.

Be helpful, concise, and friendly. When generating interactive content, make it practical and useful.`;
}
```

### 5. Chat API Route (`src/app/api/chat/route.ts`)

```typescript
import { streamText, convertToModelMessages } from "ai";
import { createModel } from "@/lib/ai/models.server";
import { getSystemPrompt } from "@/lib/ai/prompts";
import { chatTools } from "@/lib/ai/tools";

export const maxDuration = 60;

export async function POST(req: Request) {
  const { messages: uiMessages, modelId } = await req.json();

  const model = createModel(modelId);
  const messages = await convertToModelMessages(uiMessages);

  const result = streamText({
    model,
    system: getSystemPrompt(),
    messages,
    tools: chatTools,
  });

  return result.toUIMessageStreamResponse({
    sendReasoning: true,
  });
}
```

---

## Component Architecture

### 1. ChatProvider (`src/components/chat/ChatProvider.tsx`)

```typescript
'use client';

import {
  createContext,
  useContext,
  useCallback,
  useMemo,
  useState,
} from 'react';
import { useChat as useAIChat } from '@ai-sdk/react';
import { DefaultChatTransport } from 'ai';
import type { UIMessage, ChatStatus } from 'ai';
import { DEFAULT_MODEL_ID } from '@/lib/ai/models';

interface ChatContextValue {
  messages: UIMessage[];
  status: ChatStatus;
  isLoading: boolean;
  error: Error | null;
  sendMessage: (content: string) => void;
  regenerateLastMessage: () => void;
  clearMessages: () => void;
  stop: () => void;
  modelId: string;
  setModelId: (modelId: string) => void;
}

const ChatContext = createContext<ChatContextValue | undefined>(undefined);

export function ChatProvider({ children }: { children: React.ReactNode }) {
  const [modelId, setModelId] = useState<string>(DEFAULT_MODEL_ID);

  const {
    messages,
    status,
    error,
    sendMessage: aiSendMessage,
    stop,
    setMessages,
  } = useAIChat({
    transport: new DefaultChatTransport({
      api: '/api/chat',
    }),
  });

  const isLoading = status === 'submitted' || status === 'streaming';

  const sendMessage = useCallback(
    (content: string) => {
      aiSendMessage({ text: content }, { body: { modelId } });
    },
    [aiSendMessage, modelId]
  );

  const regenerateLastMessage = useCallback(() => {
    const lastUserMessageIndex = [...messages].reverse().findIndex(m => m.role === 'user');
    if (lastUserMessageIndex >= 0) {
      const index = messages.length - 1 - lastUserMessageIndex;
      const lastUserMessage = messages[index];
      const textPart = lastUserMessage.parts?.find(
        (p): p is { type: 'text'; text: string } => p.type === 'text'
      );
      if (textPart) {
        setMessages(messages.slice(0, index));
        setTimeout(() => {
          aiSendMessage({ text: textPart.text }, { body: { modelId } });
        }, 100);
      }
    }
  }, [messages, setMessages, aiSendMessage, modelId]);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, [setMessages]);

  const contextValue: ChatContextValue = useMemo(
    () => ({
      messages,
      status,
      isLoading,
      error: error ?? null,
      sendMessage,
      regenerateLastMessage,
      clearMessages,
      stop,
      modelId,
      setModelId,
    }),
    [messages, status, isLoading, error, sendMessage, regenerateLastMessage, clearMessages, stop, modelId]
  );

  return (
    <ChatContext.Provider value={contextValue}>{children}</ChatContext.Provider>
  );
}

export function useChat() {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
}
```

### 2. ChatContainer (`src/components/chat/ChatContainer.tsx`)

```typescript
'use client';

import { useMemo } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import { MessageSquare } from 'lucide-react';
import { useChat } from './ChatProvider';
import { ChatMessage } from './ChatMessage';
import {
  Conversation,
  ConversationContent,
  ConversationEmptyState,
  ConversationScrollButton,
} from '@/components/ai-elements/conversation';
import { Loader } from '@/components/ai-elements/loader';
import { cn } from '@/lib/utils';
import { fadeInUp } from '@/lib/motion';

export function ChatContainer({ className }: { className?: string }) {
  const { messages, status } = useChat();

  const messageHasContent = (message: typeof messages[number]) => {
    return message.parts?.some((part) => {
      if (part.type === 'text') {
        return (part as { type: 'text'; text: string }).text.length > 0;
      }
      if (part.type.startsWith('tool-')) {
        return true;
      }
      return false;
    });
  };

  const visibleMessages = useMemo(() => {
    return messages.filter((message) => {
      if (message.role === 'user') return true;
      return messageHasContent(message);
    });
  }, [messages]);

  const showLoading = useMemo(() => {
    if (status === 'submitted') return true;
    if (status === 'streaming') {
      const lastMessage = messages[messages.length - 1];
      if (lastMessage?.role === 'assistant') {
        return !messageHasContent(lastMessage);
      }
    }
    return false;
  }, [status, messages]);

  return (
    <Conversation className={cn('flex-1', className)}>
      <ConversationContent className="max-w-3xl mx-auto px-4 py-6">
        {visibleMessages.length === 0 ? (
          <ConversationEmptyState
            icon={<MessageSquare className="size-12" />}
            title="Start a conversation"
            description="Ask me anything. I can also create interactive forms, charts, code snippets, and more."
          />
        ) : (
          visibleMessages.map((message) => (
            <ChatMessage key={message.id} message={message} />
          ))
        )}

        <AnimatePresence>
          {showLoading && (
            <motion.div
              key="loading"
              initial="hidden"
              animate="visible"
              exit="hidden"
              variants={fadeInUp}
              className="flex items-center gap-2 text-muted-foreground text-sm"
            >
              <Loader size={16} />
              <span>Thinking...</span>
            </motion.div>
          )}
        </AnimatePresence>
      </ConversationContent>
      <ConversationScrollButton />
    </Conversation>
  );
}
```

### 3. ContentBlock Router (`src/components/blocks/ContentBlock.tsx`)

```typescript
'use client';

import { memo } from 'react';
import { FormContent } from './FormContent';
import { ChartContent } from './ChartContent';
import { CodeContent } from './CodeContent';
import { CardContent } from './CardContent';
import type { ContentBlock as ContentBlockType } from '@/types';

interface ContentBlockProps {
  content: ContentBlockType;
  messageId: string;
}

export const ContentBlock = memo(function ContentBlock({
  content,
  messageId,
}: ContentBlockProps) {
  switch (content.type) {
    case 'form':
      return <FormContent content={content} messageId={messageId} />;
    case 'chart':
      return <ChartContent content={content} messageId={messageId} />;
    case 'code':
      return <CodeContent content={content} messageId={messageId} />;
    case 'card':
      return <CardContent content={content} messageId={messageId} />;
    default:
      return null;
  }
});
```

---

## State Management

### Provider Composition

```
RootLayout
├── ThemeProvider (theme state, localStorage persistence)
│   └── QueryProvider (TanStack Query client)
│       └── Page
│           └── ChatProvider (useChat hook, model selection)
│               └── Chat Components
```

### Key State Flows

1. **Theme State**: `ThemeProvider` → localStorage → CSS classes on `<html>`
2. **Chat State**: `useChat` hook → `/api/chat` → SSE streaming → `UIMessage[]`
3. **Model State**: `ChatProvider.modelId` → passed in request body → server model creation

### ThemeProvider (`src/components/providers/ThemeProvider.tsx`)

```typescript
'use client';

import { createContext, useContext, useEffect, useState, useCallback } from 'react';
import type { Theme } from '@/types';

interface ThemeContextValue {
  theme: Theme;
  resolvedTheme: 'light' | 'dark';
  setTheme: (theme: Theme) => void;
  highContrast: boolean;
  setHighContrast: (enabled: boolean) => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

export function ThemeProvider({
  children,
  defaultTheme = 'system',
}: {
  children: React.ReactNode;
  defaultTheme?: Theme;
}) {
  const [theme, setThemeState] = useState<Theme>(defaultTheme);
  const [resolvedTheme, setResolvedTheme] = useState<'light' | 'dark'>('light');
  const [highContrast, setHighContrastState] = useState(false);
  const [mounted, setMounted] = useState(false);

  const getSystemTheme = useCallback((): 'light' | 'dark' => {
    if (typeof window === 'undefined') return 'light';
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  }, []);

  const resolveTheme = useCallback(
    (t: Theme): 'light' | 'dark' => t === 'system' ? getSystemTheme() : t,
    [getSystemTheme]
  );

  const applyTheme = useCallback((resolved: 'light' | 'dark', contrast: boolean) => {
    const root = document.documentElement;
    root.classList.remove('light', 'dark', 'high-contrast');
    root.classList.add(resolved);
    if (contrast) root.classList.add('high-contrast');
    root.style.colorScheme = resolved;
  }, []);

  useEffect(() => {
    const storedTheme = localStorage.getItem('sequenzia-theme') as Theme | null;
    const storedContrast = localStorage.getItem('sequenzia-high-contrast') === 'true';
    const initialTheme = storedTheme || defaultTheme;

    setThemeState(initialTheme);
    setHighContrastState(storedContrast);
    const resolved = resolveTheme(initialTheme);
    setResolvedTheme(resolved);
    applyTheme(resolved, storedContrast);
    setMounted(true);
  }, [defaultTheme, resolveTheme, applyTheme]);

  useEffect(() => {
    if (!mounted) return;
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const handleChange = () => {
      if (theme === 'system') {
        const resolved = getSystemTheme();
        setResolvedTheme(resolved);
        applyTheme(resolved, highContrast);
      }
    };
    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [theme, highContrast, mounted, getSystemTheme, applyTheme]);

  const setTheme = useCallback((newTheme: Theme) => {
    setThemeState(newTheme);
    localStorage.setItem('sequenzia-theme', newTheme);
    const resolved = resolveTheme(newTheme);
    setResolvedTheme(resolved);
    applyTheme(resolved, highContrast);
  }, [resolveTheme, highContrast, applyTheme]);

  const setHighContrast = useCallback((enabled: boolean) => {
    setHighContrastState(enabled);
    localStorage.setItem('sequenzia-high-contrast', String(enabled));
    applyTheme(resolvedTheme, enabled);
  }, [resolvedTheme, applyTheme]);

  if (!mounted) return null;

  return (
    <ThemeContext.Provider value={{ theme, resolvedTheme, setTheme, highContrast, setHighContrast }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) throw new Error('useTheme must be used within ThemeProvider');
  return context;
}
```

---

## Styling System

### CSS Variables (globals.css excerpt)

```css
@import "tailwindcss";

@theme inline {
  /* Light theme base colors using OKLch */
  --color-background: oklch(100% 0 0);
  --color-foreground: oklch(9.6% 0.005 286.07);
  --color-primary: oklch(20.5% 0 0);
  --color-primary-foreground: oklch(98.5% 0 0);
  --color-secondary: oklch(96.5% 0.001 286.07);
  --color-secondary-foreground: oklch(15.5% 0.004 286.07);
  --color-muted: oklch(96.5% 0.001 286.07);
  --color-muted-foreground: oklch(45.2% 0.012 256.07);
  --color-accent: oklch(96.5% 0.001 286.07);
  --color-accent-foreground: oklch(15.5% 0.004 286.07);
  --color-destructive: oklch(57.7% 0.245 27.33);
  --color-border: oklch(91.4% 0.004 286.07);
  --color-input: oklch(91.4% 0.004 286.07);
  --color-ring: oklch(70.5% 0.015 286.07);

  /* Border radius */
  --radius-sm: 0.125rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
  --radius-2xl: 1rem;
}

.dark {
  --color-background: oklch(14.5% 0.005 286.07);
  --color-foreground: oklch(98.5% 0 0);
  --color-primary: oklch(98.5% 0 0);
  --color-primary-foreground: oklch(20.5% 0 0);
  /* ... dark theme colors */
}
```

---

## Animation System

### Animation Variants (`src/lib/motion/variants.ts`)

```typescript
'use client';

import type { Transition, Variants } from 'motion/react';

// Spring Presets
export const springs = {
  gentle: { type: 'spring', stiffness: 120, damping: 14 } as const,
  snappy: { type: 'spring', stiffness: 400, damping: 30 } as const,
  bouncy: { type: 'spring', stiffness: 300, damping: 10 } as const,
} satisfies Record<string, Transition>;

// Entrance Variants
export const fadeIn: Variants = {
  hidden: { opacity: 0 },
  visible: { opacity: 1 },
};

export const fadeInUp: Variants = {
  hidden: { opacity: 0, y: 8 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.15, ease: 'easeOut' } },
};

// Message Variants
export const messageItemUser: Variants = {
  hidden: { opacity: 0, x: 12 },
  visible: { opacity: 1, x: 0, transition: { duration: 0.2, ease: 'easeOut' } },
};

export const messageItemAssistant: Variants = {
  hidden: { opacity: 0, x: -12 },
  visible: { opacity: 1, x: 0, transition: { duration: 0.2, ease: 'easeOut' } },
};

// Form Variants
export const formFieldContainer: Variants = {
  hidden: { opacity: 0 },
  visible: { opacity: 1, transition: { staggerChildren: 0.08 } },
};

export const formField: Variants = {
  hidden: { opacity: 0, x: -12 },
  visible: { opacity: 1, x: 0, transition: springs.snappy },
};

export const successBounce: Variants = {
  hidden: { opacity: 0, scale: 0.8 },
  visible: { opacity: 1, scale: 1, transition: springs.bouncy },
};

// Gesture Animations
export const buttonTap = { scale: 0.97 };
export const buttonHover = { scale: 1.02 };

// SVG Animations
export const checkmarkDraw: Variants = {
  hidden: { pathLength: 0, opacity: 0 },
  visible: { pathLength: 1, opacity: 1, transition: { duration: 0.4, ease: 'easeOut' } },
};
```

### Motion Hooks (`src/lib/motion/hooks.ts`)

```typescript
'use client';

import { useState, useEffect, useMemo } from 'react';
import { buttonTap, buttonHover, buttonTapMobile } from './variants';

export function useReducedMotion(): boolean {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReducedMotion(mediaQuery.matches);
    const handler = (e: MediaQueryListEvent) => setPrefersReducedMotion(e.matches);
    mediaQuery.addEventListener('change', handler);
    return () => mediaQuery.removeEventListener('change', handler);
  }, []);

  return prefersReducedMotion;
}

export function useIsMobile(): boolean {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => setIsMobile(window.innerWidth < 768);
    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  return isMobile;
}

export function useAnimationConfig() {
  const prefersReducedMotion = useReducedMotion();
  const isMobile = useIsMobile();

  return useMemo(() => ({
    shouldAnimate: !prefersReducedMotion,
    isMobile,
    tapGesture: isMobile ? buttonTapMobile : buttonTap,
    hoverGesture: isMobile ? {} : buttonHover,
  }), [prefersReducedMotion, isMobile]);
}
```

---

## Type Definitions

### Message Types (`src/types/message.ts`)

```typescript
import { z } from 'zod';

// Form Types
export interface FormFieldOption {
  label: string;
  value: string;
}

export interface FormField {
  id: string;
  type: 'text' | 'textarea' | 'select' | 'checkbox' | 'radio' | 'date' | 'slider' | 'file' | 'number' | 'email';
  label: string;
  placeholder?: string;
  required?: boolean;
  defaultValue?: string | number | boolean;
  options?: FormFieldOption[];
  min?: number;
  max?: number;
  step?: number;
}

export const FormFieldSchema = z.object({
  id: z.string(),
  type: z.enum(['text', 'textarea', 'select', 'checkbox', 'radio', 'date', 'slider', 'file', 'number', 'email']),
  label: z.string(),
  placeholder: z.string().optional(),
  required: z.boolean().optional(),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
  options: z.array(z.object({ label: z.string(), value: z.string() })).optional(),
  min: z.number().optional(),
  max: z.number().optional(),
  step: z.number().optional(),
});

// Content Block Types
export interface FormContentData {
  type: 'form';
  title: string;
  description?: string;
  fields: FormField[];
  submitLabel?: string;
}

export interface ChartContentData {
  type: 'chart';
  chartType: 'line' | 'bar' | 'pie' | 'area';
  title: string;
  description?: string;
  data: { label: string; value: number }[];
}

export interface CodeContentData {
  type: 'code';
  language: string;
  filename?: string;
  code: string;
  editable?: boolean;
  showLineNumbers?: boolean;
}

export interface CardContentData {
  type: 'card';
  title: string;
  description?: string;
  content?: string;
  media?: { type: 'image' | 'video'; url: string; alt?: string };
  actions?: { label: string; action: string; variant?: 'default' | 'secondary' | 'destructive' | 'outline' }[];
}

export type ContentBlock =
  | FormContentData
  | ChartContentData
  | CodeContentData
  | CardContentData;

// Zod Schemas for each (used in tools.ts)
export const FormContentDataSchema = z.object({
  type: z.literal('form'),
  title: z.string(),
  description: z.string().optional(),
  fields: z.array(FormFieldSchema),
  submitLabel: z.string().optional(),
});

export const ChartContentDataSchema = z.object({
  type: z.literal('chart'),
  chartType: z.enum(['line', 'bar', 'pie', 'area']),
  title: z.string(),
  description: z.string().optional(),
  data: z.array(z.object({ label: z.string(), value: z.number() })),
});

export const CodeContentDataSchema = z.object({
  type: z.literal('code'),
  language: z.string(),
  filename: z.string().optional(),
  code: z.string(),
  editable: z.boolean().optional(),
  showLineNumbers: z.boolean().optional(),
});

export const CardContentDataSchema = z.object({
  type: z.literal('card'),
  title: z.string(),
  description: z.string().optional(),
  content: z.string().optional(),
  media: z.object({
    type: z.enum(['image', 'video']),
    url: z.string(),
    alt: z.string().optional(),
  }).optional(),
  actions: z.array(z.object({
    label: z.string(),
    action: z.string(),
    variant: z.enum(['default', 'secondary', 'destructive', 'outline']).optional(),
  })).optional(),
});
```

### Theme Types (`src/types/theme.ts`)

```typescript
export type Theme = 'light' | 'dark' | 'system';
```

### Index Export (`src/types/index.ts`)

```typescript
export * from './message';
export * from './theme';
export * from './conversation';
```

---

## Key Architectural Patterns

### 1. Tool-Based Content Generation
- AI tools return structured data matching Zod schemas
- Tool outputs are rendered by specialized `ContentBlock` components
- Each content type has its own renderer (Form, Chart, Code, Card)

### 2. Server-Side Model Abstraction
- `models.server.ts` is marked `"server-only"` to prevent client bundle inclusion
- Uses Vercel AI Gateway for multi-provider routing
- Optional DevTools middleware for debugging

### 3. Streaming UI Pattern
- `streamText()` on server streams SSE responses
- `toUIMessageStreamResponse()` converts to UIMessage format
- Client uses `useChat` hook to manage streaming state
- Components filter empty messages during early streaming

### 4. Memoized Context Values
- All context providers memoize their values
- Prevents unnecessary re-renders in child components
- Callbacks include proper dependencies

### 5. Animation Integration
- Framer Motion variants for consistent animations
- Gesture support (tap/hover) with mobile optimization
- Reduced motion preference respected

### 6. Hydration-Safe Theme
- ThemeProvider returns null until mounted
- Prevents flash of incorrect theme during SSR

---

## Testing the Recreation

1. Start the development server:
   ```bash
   npm run dev
   ```

2. Open http://localhost:3000

3. Test features:
   - Send a message to test streaming
   - Ask for a form to test tool generation
   - Ask for a chart with data visualization
   - Switch models in the model selector
   - Toggle theme between light/dark/system

4. Debug mode (optional):
   ```bash
   AI_DEBUG=true npm run dev
   # In another terminal:
   npx @ai-sdk/devtools
   ```

---

## Summary

This documentation provides a complete blueprint for recreating Sequenzia AI. The key aspects are:

1. **Modern Stack**: Next.js 16 + React 19 + Vercel AI SDK v6
2. **Tool-Based AI**: Zod-validated tools generate structured content
3. **Component Library**: shadcn/ui + Vercel AI Elements for chat-specific UI (Conversation, Message, PromptInput, Tool, Reasoning, CodeBlock)
4. **State Management**: React Context + AI SDK hooks
5. **Animations**: Framer Motion with accessibility considerations
6. **Multi-Provider AI**: Vercel AI Gateway for model flexibility

The architecture emphasizes separation of concerns, type safety, and a polished user experience with streaming updates and interactive content blocks.
